{% load static %}
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Synin</title>
  <!-- Main stylesheet: edit styles in static/css/app.css -->
  <link rel="stylesheet" href="{% static 'css/app.css' %}">
</head>
<body>
<!--
  index.html layout overview
  - header.topbar: top controls (new/clear/stream/stop/settings + status)
  - .app-shell: split layout with .sidebar (conversations) and main.chat-shell
  - #banner: small notification area (hidden by default)
  - #chat: chat message container (bubbles inserted by JS)
  - #composer: message input form (textarea + send button)
  - <template> elements: DOM templates for user & assistant bubbles
  - #settings-modal: modal dialog for adjustable settings

  To change API endpoints, search for '/api/...' inside the embedded script.
  To change UX text (button labels, placeholders), edit the HTML below.
-->

<header class="topbar">
  <!-- Brand / app name -->
  <div class="brand">Synin</div>

  <!-- Right-aligned top controls. IDs are referenced by the inline JS. -->
  <div class="right">
    <button id="new-chat" class="ghost">New</button>
    <button id="clear-chat" class="ghost">Clear</button>

    <!-- Toggle streaming on/off. Checked by default. -->
    <label class="stream-toggle">
      <input type="checkbox" id="use-stream" checked />
      <span>Stream</span>
    </label>

    <!-- Stop button is enabled only while a streaming response is active. -->
    <button id="stop-gen" class="accent" disabled>Stop</button>
    <button id="open-settings" class="ghost">Settings</button>

    <!-- Small status indicator. JS will add the 'ok' class when backend health is OK. -->
    <div class="status" id="status-dot" title="LM Studio status"></div>
  </div>
</header>


<div class="app-shell">
  <!-- Sidebar: renders the list of conversations fetched from the server -->
  <aside class="sidebar">
    <div class="sidebar-header">
      <span class="sidebar-title">Chats</span>
      <span class="chat-count" id="chat-count">0</span> <!-- updated by JS -->
    </div>
    <div id="conversation-list" class="conversation-list"></div>
  </aside>

  <!-- Main chat area -->
  <main class="chat-shell">
    <!-- Banner: used to display transient errors or notices. Hidden by default. -->
    <div id="banner" class="banner hidden"></div>

    <!-- Messages are appended here as bubble elements created from the templates below -->
    <div id="chat" class="chat"></div>

    <!-- Composer: the input form. Enter sends, Shift+Enter inserts a newline. -->
    <form id="composer" class="composer">
      <textarea id="prompt" rows="1" placeholder="Message Synin‚Ä¶ (Enter to send, Shift+Enter = new line)"></textarea>
      <button id="send" type="submit">Send</button>
    </form>
  </main>
</div>

<!-- DOM templates for chat bubbles. Keep these minimal ‚Äî content is injected into .content -->
<template id="bubble-user">
  <div class="bubble user">
    <div class="avatar">üßë‚Äçüíª</div>
    <div class="content"></div>
  </div>
</template>

<template id="bubble-assistant">
  <div class="bubble assistant">
    <div class="avatar">ü§ñ</div>
    <div class="content"></div>
  </div>
</template>

<!-- Settings modal
     - Model list is populated async from /api/models
     - Temperature and max tokens are persisted to localStorage
     - IDs here are used by the JS below: model, temperature, max-tokens, save-settings
-->
<div id="settings-modal" class="modal hidden" aria-hidden="true">
  <div class="modal-card">
    <div class="modal-header">
      <h3>Settings</h3>
      <button id="close-settings" class="ghost small">‚úï</button>
    </div>
    <div class="modal-body">
      <label class="field">
        <span>Model</span>
        <select id="model">
          <option value="">(loading‚Ä¶)</option>
        </select>
      </label>

      <label class="field">
        <span>Temperature <em id="temp-val">0.2</em></span>
        <input id="temperature" type="range" min="0" max="1" step="0.05" value="0.2" />
      </label>

      <label class="field">
        <span>Max tokens (optional)</span>
        <input id="max-tokens" type="number" min="1" placeholder="e.g., 512" />
      </label>
    </div>
    <div class="modal-footer">
      <button id="save-settings" class="accent">Save</button>
    </div>
  </div>
</div>


<script>
  // --------------------------------------------------
  // Small inline JS for UI behavior and API integration
  // Keep edits here minimal: comments explain where to change endpoints and defaults.
  // --------------------------------------------------

  // banner: used to show transient errors/notifications
  const banner = document.getElementById('banner');
  function showError(msg) {
    banner.textContent = msg;
    banner.classList.remove('hidden');
    // hide after 5s ‚Äî adjust duration here if desired
    setTimeout(() => banner.classList.add('hidden'), 5000);
  }

  // safeFetch: small wrapper that supports timeouts and extracts JSON error messages when possible
  async function safeFetch(url, opts = {}, timeoutMs = 60000) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const res = await fetch(url, { ...opts, signal: ctrl.signal });
      let data = null;
      // attempt to parse JSON for richer error info, ignore parse failures
      try { data = await res.clone().json(); } catch { /* non-JSON or empty */ }
      if (!res.ok) {
        const msg = (data && (data.error || data.detail)) || `HTTP ${res.status}`;
        throw new Error(msg);
      }
      // return parsed JSON when available, otherwise raw text
      return data ?? await res.text();
    } finally {
      clearTimeout(t);
    }
  }

  // --- elements (cached references) ---
  const chat = document.getElementById('chat');
  const form = document.getElementById('composer');
  const promptEl = document.getElementById('prompt');
  const sendBtn = document.getElementById('send');
  const statusDot = document.getElementById('status-dot');
  const useStreamEl = document.getElementById('use-stream');
  const btnNew = document.getElementById('new-chat');
  const btnClear = document.getElementById('clear-chat');
  const btnStop = document.getElementById('stop-gen');
  const btnOpenSettings = document.getElementById('open-settings');
  const conversationList = document.getElementById('conversation-list');
  const chatCountEl = document.getElementById('chat-count');

  // Settings modal elements
  const modal = document.getElementById('settings-modal');
  const btnCloseSettings = document.getElementById('close-settings');
  const btnSaveSettings = document.getElementById('save-settings');
  const selModel = document.getElementById('model');
  const rangeTemp = document.getElementById('temperature');
  const tempVal = document.getElementById('temp-val');
  const inputMax = document.getElementById('max-tokens');

  // --- state ---
  // SYSTEM_PROMPT: the assistant system message. Edit if you want a different assistant persona.
  const SYSTEM_PROMPT = 'You are Synin, a concise, helpful assistant.';
  let messages = [{ role: 'system', content: SYSTEM_PROMPT }];
  let conversationId = null; // server-provided conversation id when available
  let conversations = []; // cached conversations list
  let abortCtrl = null; // used to cancel streaming requests

  // --- settings storage (localStorage) ---
  const SETTINGS_KEY = 'synin_settings_v1';
  function loadSettings() {
    try {
      const raw = localStorage.getItem(SETTINGS_KEY);
      return raw ? JSON.parse(raw) : { model: '', temperature: 0.2, max_tokens: null };
    } catch { return { model: '', temperature: 0.2, max_tokens: null }; }
  }
  function saveSettings(s) {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(s));
  }
  let settings = loadSettings();

  // apply persisted settings to UI controls
  function applySettingsToUI() {
    rangeTemp.value = settings.temperature ?? 0.2;
    tempVal.textContent = String(rangeTemp.value);
    inputMax.value = settings.max_tokens ?? '';
    // Note: selModel is populated async in populateModels()
  }

  // Load available models from backend and populate select
  // Edit endpoint here if your backend uses a different path.
  async function populateModels() {
    try {
      const res = await fetch('/api/models');
      const data = await res.json();
      const models = (data?.data || []).map(m => m.id).filter(Boolean);
      selModel.innerHTML = '';
      for (const id of models) {
        const opt = document.createElement('option');
        opt.value = id;
        opt.textContent = id;
        selModel.appendChild(opt);
      }
      // set saved model or default to first
      if (settings.model && models.includes(settings.model)) {
        selModel.value = settings.model;
      } else if (models.length && !selModel.value) {
        selModel.value = models[0];
      }
    } catch {
      selModel.innerHTML = '<option value="">(failed to load)</option>';
    }
  }

  // Render conversation list in the sidebar from `conversations` state
  function renderConversations() {
    if (!conversationList) return;
    conversationList.innerHTML = '';
    if (chatCountEl) {
      chatCountEl.textContent = String(conversations.length);
    }
    if (!conversations.length) {
      const empty = document.createElement('div');
      empty.className = 'sidebar-empty';
      empty.textContent = 'No chats yet.';
      conversationList.appendChild(empty);
      return;
    }
    for (const conv of conversations) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'conversation-item';
      if (conv.id === conversationId) {
        btn.classList.add('active');
      }
      btn.dataset.id = conv.id;

      const title = document.createElement('div');
      title.className = 'conversation-title';
      const displayTitle = (conv.title && conv.title.trim()) ? conv.title : 'Untitled chat';
      title.textContent = displayTitle;

      const meta = document.createElement('div');
      meta.className = 'conversation-meta';
      const totalMessages = Number(conv.message_count || 0);
      const visibleMessages = Math.max(0, totalMessages - 1); // subtract system prompt
      meta.textContent = visibleMessages === 0
        ? 'No messages yet'
        : `${visibleMessages} message${visibleMessages === 1 ? '' : 's'}`;

      btn.append(title, meta);
      conversationList.appendChild(btn);
    }
  }

  // Fetch list of conversations from the backend and update UI
  async function refreshConversations() {
    if (!conversationList) return;
    try {
      const data = await safeFetch('/api/conversations');
      const list = Array.isArray(data?.data) ? data.data : [];
      conversations = list;
      renderConversations();
    } catch (err) {
      console.warn('Failed to load conversations', err);
    }
  }

  // Load a single conversation by id and render its messages
  async function loadConversation(id) {
    if (!id) return;
    if (abortCtrl) {
      // cancel any in-progress streaming request before switching
      abortCtrl.abort();
    }
    try {
      const data = await safeFetch(`/api/conversations/${id}`);
      conversationId = data?.id || id;
      const rawMessages = Array.isArray(data?.messages) ? data.messages : [];
      const history = [];
      let hasSystem = false;
      for (const msg of rawMessages) {
        if (!msg || typeof msg.content !== 'string') continue;
        if (msg.role === 'system') {
          if (hasSystem) continue;
          hasSystem = true;
        }
        history.push({ role: msg.role, content: msg.content });
      }
      if (!hasSystem) {
        history.unshift({ role: 'system', content: SYSTEM_PROMPT });
      }
      messages = history;
      chat.innerHTML = '';
      for (const msg of messages) {
        if (msg.role === 'user' || msg.role === 'assistant') {
          addBubble(msg.role, msg.content);
        }
      }
      renderConversations();
      promptEl.focus();
    } catch (err) {
      showError(`Failed to load conversation: ${err.message}`);
    }
  }

  // --- helpers ---
  // quick health check: backend must respond at /api/health
  fetch('/api/health').then(r => r.ok ? statusDot.classList.add('ok') : null).catch(()=>{});

  function scrollToBottom() {
    chat.parentElement.scrollTop = chat.parentElement.scrollHeight;
  }

  // create and append a bubble using the <template> elements above
  function addBubble(role, text) {
    const tplId = role === 'user' ? 'bubble-user' : 'bubble-assistant';
    const tpl = document.getElementById(tplId);
    const node = tpl.content.cloneNode(true);
    node.querySelector('.content').textContent = text;
    chat.appendChild(node);
    scrollToBottom();
  }

  // toggle UI while waiting for a response
  function setSending(on) {
    sendBtn.disabled = on;
    promptEl.disabled = on;
    btnStop.disabled = !on;
    sendBtn.textContent = on ? 'Sending‚Ä¶' : 'Send';
  }

  // currentPayload: assemble the request payload sent to the server
  function currentPayload() {
    const payload = { messages };
    if (settings.model) payload.model = settings.model;
    if (settings.temperature != null) payload.temperature = Number(settings.temperature);
    if (settings.max_tokens) payload.max_tokens = Number(settings.max_tokens);
    if (conversationId) payload.conversation_id = conversationId;
    return payload;
  }

  // Non-streaming POST call: backend should return JSON { ok: true, assistant: '...' }
  async function callNonStreaming() {
    const res = await fetch('/api/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(currentPayload())
    });
    const data = await res.json();
    if (!res.ok || !data.ok) throw new Error(data.error || 'Request failed');
    if (data.conversation_id) conversationId = data.conversation_id;
    return data.assistant || '';
  }

  // Streaming call: server must send SSE-like chunks separated by "\n\n" and prefixed with "data:"
  async function callStreaming(onChunk) {
    abortCtrl = new AbortController();
    const res = await fetch('/api/chat/stream', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(currentPayload()),
      signal: abortCtrl.signal
    });
    const cid = res.headers.get('x-conversation-id');
    if (cid) conversationId = cid;

    if (!res.ok || !res.body) {
      let msg = 'Streaming request failed';
      try { const j = await res.json(); msg = j.error || msg; } catch {}
      throw new Error(msg);
    }

    const reader = res.body.getReader();
    const decoder = new TextDecoder('utf-8');
    let buffer = '';

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });

        // SSE style: messages separated by double-newline. We keep any partial chunk in buffer.
        const parts = buffer.split('\n\n');
        buffer = parts.pop();
        for (const part of parts) {
          const line = part.trim();
          if (!line.startsWith('data:')) continue;
          const payload = line.slice(5).trim();
          if (payload === '[DONE]') return;
          try {
            const json = JSON.parse(payload);
            let chunk = json?.choices?.[0]?.delta?.content;
            if (!chunk && json?.choices?.[0]?.text) chunk = json.choices[0].text;
            if (chunk) onChunk(chunk);
          } catch {}
        }
      }
    } finally {
      abortCtrl = null;
    }
  }

  // conversation selection
  if (conversationList) {
    conversationList.addEventListener('click', (event) => {
      const item = event.target.closest('.conversation-item');
      if (!item) return;
      const id = item.dataset.id;
      if (!id || id === conversationId) return;
      loadConversation(id);
    });
  }

  // ---- compose/submit ----
  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const text = promptEl.value.trim();
    if (!text) return;
    const MAX_USER_LEN = 4000; // safeguard to avoid huge requests
    if (text.length > MAX_USER_LEN) {
      showError(`Message is too long (max ${MAX_USER_LEN} chars).`);
      return;
    }
    if (messages.length > 200) {
      showError('This chat is very long; start a new chat to keep things snappy.');
      return;
    }
    addBubble('user', text);
    messages.push({ role: 'user', content: text });
    promptEl.value = '';
    promptEl.style.height = 'auto';
    setSending(true);

    try {
      if (useStreamEl.checked) {
        // create assistant bubble to stream into
        const tpl = document.getElementById('bubble-assistant');
        const node = tpl.content.cloneNode(true);
        const contentEl = node.querySelector('.content');
        chat.appendChild(node);
        scrollToBottom();

        await callStreaming((chunk) => {
          contentEl.textContent += chunk;
          scrollToBottom();
        });

        messages.push({ role: 'assistant', content: contentEl.textContent });
        await refreshConversations();
      } else {
        const reply = await callNonStreaming();
        messages.push({ role: 'assistant', content: reply });
        addBubble('assistant', reply);
        await refreshConversations();
      }
    } catch (err) {
      addBubble('assistant', '‚ö†Ô∏è ' + err.message);
    } finally {
      setSending(false);
      promptEl.focus();
    }
  });

  // stop/abort streaming
  btnStop.addEventListener('click', () => {
    if (abortCtrl) {
      abortCtrl.abort();
    }
  });

  // textarea UX: auto-resize and submit on Enter (unless Shift is held)
  promptEl.addEventListener('input', () => {
    promptEl.style.height = 'auto';
    promptEl.style.height = Math.min(promptEl.scrollHeight, 160) + 'px';
  });
  promptEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      form.dispatchEvent(new Event('submit'));
    }
  });

  // new / clear chat controls
  btnNew.addEventListener('click', () => {
    conversationId = null;
    messages = [{ role: 'system', content: SYSTEM_PROMPT }];
    chat.innerHTML = '';
    addBubble('assistant', 'üÜï New chat started.');
    renderConversations();
  });
  btnClear.addEventListener('click', async () => {
    if (!conversationId) {
      // if not in a saved conversation, just clear local chat UI
      chat.innerHTML = '';
      messages = [{ role: 'system', content: SYSTEM_PROMPT }];
      renderConversations();
      return;
    }
    try {
      // backend endpoint to clear conversation
      await fetch(`/api/conversations/${conversationId}/clear`, { method: 'POST' });
      chat.innerHTML = '';
      messages = [{ role: 'system', content: SYSTEM_PROMPT }];
      addBubble('assistant', 'üßπ Conversation cleared.');
      await refreshConversations();
    } catch {
      addBubble('assistant', '‚ö†Ô∏è Failed to clear conversation.');
    }
  });

  // settings modal open/close helpers
  function openModal() { modal.classList.remove('hidden'); modal.setAttribute('aria-hidden', 'false'); }
  function closeModal() { modal.classList.add('hidden'); modal.setAttribute('aria-hidden', 'true'); }

  btnOpenSettings.addEventListener('click', () => { applySettingsToUI(); openModal(); });
  btnCloseSettings.addEventListener('click', closeModal);
  modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });

  // live update temperature display
  rangeTemp.addEventListener('input', () => { tempVal.textContent = String(rangeTemp.value); });

  // save settings to localStorage
  btnSaveSettings.addEventListener('click', () => {
    settings.temperature = Number(rangeTemp.value);
    settings.max_tokens = inputMax.value ? Number(inputMax.value) : null;
    settings.model = selModel.value || '';
    saveSettings(settings);
    closeModal();
    addBubble('assistant', '‚úÖ Settings saved.');
  });

  // initial load: populate models, apply saved settings, and fetch conversations
  (async () => {
    await populateModels();
    applySettingsToUI();
    await refreshConversations();
  })();
</script>


</body>
</html>
